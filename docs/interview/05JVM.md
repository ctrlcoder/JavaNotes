### 运行时的数据区域

**线程私有的：**

- 程序计数器 **为了线程切换后能恢复到正确的执行位置**
- 虚拟机栈 **局部变量表**
- 本地方法栈  **Native 方法**

**线程共享的：**

- 堆 **存放对象实例**
- 方法区 **已被虚拟机加载的类信息、常量、静态变量**
- 直接内存 (非运行时数据区的一部分)



### 垃圾判断（对象回收判断）

- **引用计数算法** 在对象头中分配一个空间来保存该对象被引用的次数
- **可达性分析算法** 当一个对象到 GC Roots 没有任何引用链相连，则对象不可用



### 垃圾回收算法

- **标记清理算法** 内存碎片问题
- **复制算法**   平分代价太高
- **标记整理算法**  内存变动频繁，效率低
- **分代收集算法**  新生代  少量存活 用复制算法 老年代 用标记清理或整理算法



### 垃圾回收过程

- 新生代
  - Eden区 对象会在新生代 Eden 区中进行分配，当 Eden 区没有足够空间进行分配时，虚拟机会发起一次 **Minor GC**
  - Survivor区 无需回收的存活对象，将会进到 Survivor 
    - Form区
    - To区  设置两个 Survivor 区最大的好处就是解决内存碎片化

- 老年代
  经历15次MinorGC存活的对象

  

### 垃圾收集器

- Serial 收集器
- parNew收集器
- Parallel Scavenge 收集器
- CMS收集器 标记-清除算法
- G1收集器 复制+标记-整理算法 ；年轻代和老年代不再物理隔离





### Java中的强引用、软引用、弱引用、虚引用

**强引用** 

在程序代码中普遍存在的，类似 Object obj = new Object() 这类引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。 

**软引用** 

用来描述一些还有用但并非必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存溢出异常。 

 **弱引用** 

也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。 

**虚引用** 

也叫幽灵引用或幻影引用，是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。它的作用是能在这个对象被收集器回收时收到一个系统通知。 

![1568523388814](../img/1568523388814-1569558098984.png)



#### 内存泄漏

内存泄漏就是存在一些不会再被使用确没有被回收的对象

- 静态集合类引起的内存泄漏‘

- 各种连接没有显示关闭

- 内部类：内部类的引用是比较容易遗忘的一种，而且一旦没释放可能导致一系列的后继 

  类对象没有释放 

### 类加载

**虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这就是虚拟机的类加载机制。** 

- 加载
- 验证
- 准备 **准备阶段是正式为类变量分配内存并设置类变量初始值的阶段**
- 解析 **解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程**
- 初始化



### 类加载器

1. **BootstrapClassLoader(启动类加载器)** ：最顶层的加载类，由C++实现，负责加载 `%JAVA_HOME%/lib`目录下的jar包和类或者或被 `-Xbootclasspath`参数指定的路径中的所有类。
2. **ExtensionClassLoader(扩展类加载器)** ：主要负责加载目录 `%JRE_HOME%/lib/ext` 目录下的jar包和类，或被 `java.ext.dirs` 系统变量所指定的路径下的jar包。
3. **AppClassLoader(应用程序类加载器)** :面向我们用户的加载器，负责加载当前应用classpath下的所有jar包和类。

### 双亲委派模型

如果一个类加载器收到了类加载请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成。每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。 

**好处**

双亲委派模型保证了Java程序的稳定运行，可以避免类的重复加载（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也保证了 Java 的核心 API 不被篡改。

