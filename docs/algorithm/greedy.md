>  贪心算法有很多经典的应用，比如霍夫曼编码（Huffman Coding）、Prim和Kruskal最小生成树算法、还有Dijkstra单源最短路径算法。

## 贪心算法解决问题的步骤

第一步，当我们看到这类问题的时候，首先要联想到贪心算法：针对一组数据，我们定义了限制值和期望值，希望从中选出几个数据，**在满足限制值的情况下， 期望值最大。** 

第二步，我们尝试看下这个问题是否可以用贪心算法解决：每次选择当前情况下，在对限制值同等贡献量的情况下，对期望值贡献最大的数据。

第三步，我们举几个例子看下贪心算法产生的结果是否是最优的。大部分情况下，举几个例子验证一下就可以了。严格地证明贪心算法的正确性，是非常复杂的，需要涉及比较多的数学推理。而且，从实践的角度来说，大部分能用贪心算法解决的问题，贪心算法的正确性都是显而易见的，也不需要严格的数学推导证明。 

实际上，用贪心算法解决问题的思路，并不总能给出最优解。 

> 对于贪心算法，你是不是还有点懵？如果死抠理论的话，确实很难理解透彻。掌握贪心算法的关键是多练习。

#### [343\. 整数拆分](https://leetcode-cn.com/problems/integer-break/)
给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。
示例 1:
输入: 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1。
示例 2:
输入: 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。
说明: 你可以假设 n 不小于 2 且不大于 58。

---

从小规模数据找规律
我们不妨从最小的正整数加法因子 1 开始，到 2、3、4、...，依次分析，分解以后，乘积的大小，写几个出来，看看规律。
在大于 4 的前提下，尽可能分解出 3 。当n≤4 的时候，专门计算一下给出结论就可以了。
“贪心地”、“尽可能多”地分解出 3 正整这个加法因子，就能够使得最终的乘积得到最大。

---

```java
class Solution {
    public int integerBreak(int n) {
        if (n <= 2) {   return 1;    }
        if (n == 3) {   return 2;    }
        if (n == 4) {   return 4;    }
        // 接下来就是 n >= 5 的时候的逻辑了
        int res = 1;
        while (n > 4) {
            res *= 3;
            n -= 3;
        }
        res *= n;
        return res;
    }

}
```

#### [122\. 买卖股票的最佳时机 II](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)
给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。
设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。
注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

示例 1:
输入: [7,1,5,3,6,4]
输出: 7
解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。
     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。

---

只看今明两天，只要明天比今天贵，那今天买明天卖就赚到，否则不做操作，以此类推即可。
思路是遍历整个股票交易日价格列表price，将所有上涨交易日的利润都赚到，所有下降交易日都不买卖；
- 设 tmp 为第 i-1 天卖和 i 天买可以赚取的利润，即 prices[i] - prices[i - 1] ；
- 当该天利润为正 tmp > 0 ，则将利润加入总利润 profit ；
- 遍历完成后返回总利润 profit 

---

```java
class Solution {
    public int maxProfit(int[] prices) {
        int maxprofit = 0;
        for (int i = 1; i < prices.length; i++) {
            if (prices[i] > prices[i - 1])
                maxprofit += prices[i] - prices[i - 1];
        }
        return maxprofit;
    }
}
```

#### [55\. 跳跃游戏](https://leetcode-cn.com/problems/jump-game/)
给定一个非负整数数组，你最初位于数组的第一个位置。
数组中的每个元素代表你在该位置可以跳跃的最大长度。
判断你是否能够到达最后一个位置。
示例 1:
输入: [2,3,1,1,4]
输出: true
解释: 从位置 0 到 1 跳 1 步, 然后跳 3 步到达最后一个位置。

---

它更适合反过来想。我们可以从数组的倒数第二个个元素看起，每次往前遍历，如果当前的元素能够到达最后一个位置，那么我们把当前位置开始到最后全部“切断”，以当前元素为最后一个元素，重复第一次的过程就好了。而最后，如果我们遍历到数组的第一个元素，那么此题返回true，否则，你懂得。

---

```java
class Solution {
    public boolean canJump(int[] nums) {
        int last = nums.length - 1;

        for(int i = nums.length - 2; i >= 0 ; i--){
            if(nums[i] + i >= last){
                last = i;
            }
        }
        return last==0;
        
    }
}
```

#### [134\. 加油站](https://leetcode-cn.com/problems/gas-station/)
在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。
你一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。
如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。
说明: 
如果题目有解，该答案即为唯一答案。
输入数组均为非空数组，且长度相同。
输入数组中的元素均为非负数。
示例 1:
输入: 
gas  = [1,2,3,4,5]
cost = [3,4,5,1,2]
输出: 3
解释:
从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油
开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油
开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油
开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油
开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油
开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。
因此，3 可为起始索引。

---

总和大于零则一定存在连续和大于零的遍历
该题目是贪心算法的典型案例。关键在于要彻底理解题目的本质，这可以帮助你想到最简单的解法。
如果无法环绕一周，那么gas[i]-cost[i]的差值累加必然小于0,；否则，就是能够环绕一周。
一次遍历，在遍历中一边累加total一边寻找正确的start。
假如total>=0，那么就返回start，否则返回-1。

---

```java
class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        int sum = 0;
        int total = 0;
        int start = 0;
        for(int i=0;i<gas.length;i++){
            total += (gas[i] - cost[i]);
            if(sum < 0){
                sum = gas[i]-cost[i];
                start = i;
            }else{
                sum += (gas[i]-cost[i]);
            }
        }
        return total >= 0?start:-1;
    }
}
```